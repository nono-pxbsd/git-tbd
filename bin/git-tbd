#!/bin/bash

# git-tbd : un mini outil CLI pour gÃ©rer un workflow Trunk-Based Development ğŸš€

BOLD="\e[1m"
GREEN="\e[32m"
YELLOW="\e[33m"
RESET="\e[0m"

# DÃ©finition des types et icÃ´nes
BRANCH_TYPES=("feature" "fix" "hotfix" "chore")
declare -A BRANCH_ICONS=(
  [feature]="âœ¨ feat"
  [fix]="ğŸ› fix"
  [hotfix]="ğŸš‘ hotfix"
  [chore]="ğŸ§¹ chore"
)

function print_help() {
  echo -e "${BOLD}git-tbd${RESET} - CLI pour workflow Trunk-Based Development\n"
  echo "Usage :"
  echo "  git-tbd start              â†’ SÃ©lection interactive du type de branche Ã  crÃ©er"
  echo "  git-tbd finish             â†’ Merge dans main + suppression de la branche"
  echo "  git-tbd sync               â†’ Met Ã  jour la branche courante depuis main"
  echo "  git-tbd pr                 â†’ Ouvre une Pull Request automatiquement"
  echo "  git-tbd bump <type>        â†’ Bump la version (major, minor, patch)"
  echo "  git-tbd help               â†’ Affiche cette aide"
}

create_branch() {
  local type="$1"
  local name="$2"

  if [[ -z "$type" || -z "$name" ]]; then
    echo -e "${YELLOW}âš ï¸  Type ou nom de branche manquant.${RESET}"
    return 1
  fi

  # Bascule sur main Ã  jour
  git checkout main &>/dev/null || {
    echo -e "${YELLOW}âš ï¸  La branche main est introuvable.${RESET}"
    return 1
  }
  git pull &>/dev/null

  local full_branch="${type}/${name}"
  git checkout -b "$full_branch"
  echo -e "${GREEN}âœ… Branche crÃ©Ã©e : ${full_branch}${RESET}"
}

# Fonction start gÃ©nÃ©rique
start() {
  local input="$1"
  local branch_type=""
  local name=""

  if [[ -n "$input" && "$input" == */* ]]; then
    branch_type="${input%%/*}"
    name="${input#*/}"
  fi

  # Si aucun type fourni, demande interactive avec fzf
  if [[ -z "$branch_type" || -z "$name" ]]; then
    if ! command -v fzf >/dev/null; then
      echo -e "${YELLOW}âš ï¸  La commande 'fzf' est requise si aucun argument n'est passÃ©.${RESET}"
      return 1
    fi
    branch_type=$(printf "%s\n" "${BRANCH_TYPES[@]}" | fzf --prompt="ğŸ§­ Type de branche ? > " --height=10%)
    [[ -z "$branch_type" ]] && { echo -e "${YELLOW}âš ï¸  Aucun type sÃ©lectionnÃ©.${RESET}"; return 1; }
    echo -ne "ğŸ“ Nom de la branche : "
    read name
    [[ -z "$name" ]] && { echo -e "${YELLOW}âš ï¸  Nom requis.${RESET}"; return 1; }
  fi

  create_branch "$branch_type" "$name"
}

start_feature() {
  local name="$1"
  if [ -z "$name" ]; then
    echo -e "${YELLOW}âš ï¸  Tu dois spÃ©cifier un nom de feature.${RESET}"
    exit 1
  fi
  create_branch "feature" "$name"
}

# Fonction finish universelle
finish() {
  local type=""
  local name=""
  local current=$(git rev-parse --abbrev-ref HEAD)

  # DÃ©duction depuis la branche actuelle
  if [[ $# -eq 0 ]]; then
    type="${current%%/*}"
    name="${current#*/}"
  elif [[ $# -eq 1 ]]; then
    if [[ "$1" == */* ]]; then
      type="${1%%/*}"
      name="${1#*/}"
    else
      type="$1"
      name="${current#*/}"
    fi
  elif [[ $# -eq 2 ]]; then
    type="$1"
    name="$2"
  else
    echo -e "${YELLOW}âš ï¸  Trop d'arguments. Usage : finish [type[/name] | type name]${RESET}"
    return 1
  fi

  # Validation du type
  if [[ ! "$type" =~ ^(feature|fix|hotfix|chore)$ ]]; then
    echo -e "${YELLOW}âš ï¸  Type non supportÃ© : $type${RESET}"
    return 1
  fi

  local branch="${type}/${name}"
  local label="${type}(${name})"

  echo -e "${GREEN}ğŸ” Fusion de la branche ${branch} dans main...${RESET}"
  git checkout main && git pull
  git merge --no-ff "$branch" -m "$label: merge ${type} into main"
  git branch -d "$branch"
  git push origin --delete "$branch" 2>/dev/null || true
  echo -e "${GREEN}âœ… Branche ${branch} fusionnÃ©e et supprimÃ©e.${RESET}"
}

function sync_branch() {
  git fetch origin
  git rebase origin/main
  echo -e "${GREEN}ğŸ”„ Branche synchronisÃ©e avec main.${RESET}"
}

function open_pr() {
  local branch=$(git rev-parse --abbrev-ref HEAD)

  branch_type=$(echo "$branch" | cut -d'/' -f1)
  branch_name=${branch#"$branch_type"/}

  case "$branch_type" in
    feature) prefix="âœ¨ feat" ;;
    fix)     prefix="ğŸ› fix" ;;
    hotfix)  prefix="ğŸš’ hotfix" ;;  # Ã  adapter si tu veux diffÃ©rencier
    chore)   prefix="ğŸ§¹ chore" ;;
    *)
      echo -e "${YELLOW}âš ï¸  Tu dois Ãªtre sur une branche (feature|fix|hotfix|chore)/* pour crÃ©er une PR.${RESET}"
      exit 1
    ;;
  esac

  local title="${prefix}(${branch_name})"
  local body="${2:-Pull request automatique depuis \`$branch\` vers \`main\`}"

  # Push si nÃ©cessaire
  git push -u origin "$branch"

  # CrÃ©ation de la PR via GitHub CLI
  gh pr create --base main --head "$branch" --title "$title" --body "$body"

  # RÃ©cupÃ©ration du lien vers la PR
  local url=$(gh pr view --json url -q ".url")
  echo -e "${GREEN}âœ… PR crÃ©Ã©e depuis $branch vers main${RESET}"
  echo -e "ğŸ”— Lien : ${BOLD}${url}${RESET}"
}

# Dispatcher
case "$1" in
  start)
    shift
    start "$1"
    ;;
  finish)
    shift
    finish "$@"
    ;;
  start_feature)
    shift
    start_feature "$1"
    ;;
  pr)
    shift
    open_pr "$@"
    ;;
  help | *)
    print_help
    ;;
esac
