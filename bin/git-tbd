#!/bin/bash

# git-tbd : un mini outil CLI pour g√©rer un workflow Trunk-Based Development üöÄ

BOLD="\e[1m"
GREEN="\e[32m"
YELLOW="\e[33m"
RESET="\e[0m"

# D√©finition des types et ic√¥nes
BRANCH_TYPES=("feature" "fix" "hotfix" "chore")
declare -A BRANCH_ICONS=(
  [feature]="‚ú® feat"
  [fix]="üêõ fix"
  [hotfix]="üöë hotfix"
  [chore]="üßπ chore"
)

function print_help() {
  echo -e "${BOLD}git-tbd${RESET} - CLI pour workflow Trunk-Based Development\n"
  echo "Usage:"
  echo "  git-tbd start <feature-name>   ‚Üí Cr√©e une branche feature/<feature-name>"
  echo "  git-tbd finish                 ‚Üí Merge dans main + suppression de la branche"
  echo "  git-tbd sync                   ‚Üí Met √† jour la branche courante depuis main"
  echo "  git-tbd help                   ‚Üí Affiche cette aide"
}

create_branch() {
  local type="$1"
  local name="$2"

  if [[ -z "$type" || -z "$name" ]]; then
    echo -e "${YELLOW}‚ö†Ô∏è  Type ou nom de branche manquant.${RESET}"
    return 1
  fi

  # Bascule sur main √† jour
  git checkout main &>/dev/null || {
    echo -e "${YELLOW}‚ö†Ô∏è  La branche main est introuvable.${RESET}"
    return 1
  }
  git pull &>/dev/null

  local full_branch="${type}/${name}"
  git checkout -b "$full_branch"
  echo -e "${GREEN}‚úÖ Branche cr√©√©e : ${full_branch}${RESET}"
}

# Fonction start g√©n√©rique
start() {
  # V√©rifie fzf
  if ! command -v fzf >/dev/null; then
    echo -e "${YELLOW}‚ö†Ô∏è  La commande 'fzf' est requise pour cette fonction.${RESET}"
    return 1
  fi

  local branch_type=$(printf "%s\n" "${BRANCH_TYPES[@]}" | fzf --prompt="üß≠ Type de branche ? > " --height=10%)
  if [[ -z "$branch_type" ]]; then
    echo -e "${YELLOW}‚ö†Ô∏è  Aucune s√©lection effectu√©e.${RESET}"
    return 1
  fi

  echo -ne "üìù Nom de la branche : "
  read name
  if [[ -z "$name" ]]; then
    echo -e "${YELLOW}‚ö†Ô∏è  Tu dois sp√©cifier un nom.${RESET}"
    return 1
  fi

  create_branch "$branch_type" "$name"
}

# Fonction finish universelle
finish() {
  local branch=$(git rev-parse --abbrev-ref HEAD)
  local type=${branch%%/*}
  local name=${branch#*/}

  case "$type" in
    feature) finish_feature "$name" ;;
    fix)     finish_fix "$name" ;;
    chore)   finish_chore "$name" ;;
    hotfix)  finish_hotfix "$name" ;;
    *)
      echo -e "${YELLOW}‚ö†Ô∏è  Type de branche non reconnu ou non support√© : $branch${RESET}"
      return 1
      ;;
  esac
}

start_feature() {
  local name="$1"
  if [ -z "$name" ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  Tu dois sp√©cifier un nom de feature.${RESET}"
    exit 1
  fi
  create_branch "feature" "$name"
}

function sync_branch() {
  git fetch origin
  git rebase origin/main
  echo -e "${GREEN}üîÑ Branche synchronis√©e avec main.${RESET}"
}

function open_pr() {
  local branch=$(git rev-parse --abbrev-ref HEAD)

  branch_type=$(echo "$branch" | cut -d'/' -f1)
  branch_name=${branch#"$branch_type"/}

  case "$branch_type" in
    feature) prefix="‚ú® feat" ;;
    fix)     prefix="üêõ fix" ;;
    hotfix)  prefix="üöí hotfix" ;;  # √† adapter si tu veux diff√©rencier
    chore)   prefix="üßπ chore" ;;
    *)
      echo -e "${YELLOW}‚ö†Ô∏è  Tu dois √™tre sur une branche (feature|fix|hotfix|chore)/* pour cr√©er une PR.${RESET}"
      exit 1
    ;;
  esac

  local title="${prefix}(${branch_name})"
  local body="${2:-Pull request automatique depuis \`$branch\` vers \`main\`}"

  # Push si n√©cessaire
  git push -u origin "$branch"

  # Cr√©ation de la PR via GitHub CLI
  gh pr create --base main --head "$branch" --title "$title" --body "$body"

  # R√©cup√©ration du lien vers la PR
  local url=$(gh pr view --json url -q ".url")
  echo -e "${GREEN}‚úÖ PR cr√©√©e depuis $branch vers main${RESET}"
  echo -e "üîó Lien : ${BOLD}${url}${RESET}"
}

# Dispatcher
case "$1" in
  start)
    shift
    start
    ;;
  finish)
    shift
    finish
    ;;
  start_feature)
    shift
    start_feature "$1"
    ;;
  finish_feature)
    shift
    finish_feature "$1"
    ;;
  pr)
    shift
    open_pr "$@"
    ;;
  help | *)
    print_help
    ;;
esac
