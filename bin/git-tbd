#!/bin/bash

# git-tbd : un mini outil CLI pour g√©rer un workflow Trunk-Based Development üöÄ

BOLD="\e[1m"
GREEN="\e[32m"
YELLOW="\e[33m"
RESET="\e[0m"

# D√©finition des types et ic√¥nes
BRANCH_TYPES=("feature" "fix" "hotfix" "chore")
declare -A BRANCH_ICONS=(
  [feature]="‚ú®"
  [fix]="üêõ"
  [chore]="üßπ"
  [refactor]="üî®"
  [test]="‚úÖ"
  [doc]="üìö"
)

# Chargement des fonctions de branche dynamique
source "${BASH_SOURCE%/*}/../lib/branches.sh"

get_branch_icon() {
  local type="$1"
  echo "${BRANCH_ICONS[$type]}"
}


function print_help() {
  echo -e "${BOLD}git-tbd${RESET} - CLI pour workflow Trunk-Based Development\n"
  echo "Usage :"
  echo "  git-tbd start              ‚Üí S√©lection interactive du type de branche √† cr√©er"
  echo "  git-tbd finish             ‚Üí Merge dans main + suppression de la branche"
  echo "  git-tbd sync               ‚Üí Met √† jour la branche courante depuis main"
  echo "  git-tbd pr                 ‚Üí Ouvre une Pull Request automatiquement"
  echo "  git-tbd bump <type>        ‚Üí Bump la version (major, minor, patch)"
  echo "  git-tbd help               ‚Üí Affiche cette aide"
}

create_branch() {
  local type="$1"
  local name="$2"

  if [[ -z "$type" || -z "$name" ]]; then
    echo -e "${YELLOW}‚ö†Ô∏è  Type ou nom de branche manquant.${RESET}"
    return 1
  fi

  # Bascule sur main √† jour
  git checkout main &>/dev/null || {
    echo -e "${YELLOW}‚ö†Ô∏è  La branche main est introuvable.${RESET}"
    return 1
  }
  git pull &>/dev/null

  local full_branch="${type}/${name}"
  git checkout -b "$full_branch"
  echo -e "${GREEN}‚úÖ Branche cr√©√©e : ${full_branch}${RESET}"
}

# Fonction start g√©n√©rique
start() {
  local input="$1"
  local branch_type=""
  local name=""

  if [[ -n "$input" && "$input" == */* ]]; then
    branch_type="${input%%/*}"
    name="${input#*/}"
  fi

  # Si aucun type fourni, demande interactive avec fzf
  if [[ -z "$branch_type" || -z "$name" ]]; then
    if ! command -v fzf >/dev/null; then
      echo -e "${YELLOW}‚ö†Ô∏è  La commande 'fzf' est requise si aucun argument n'est pass√©.${RESET}"
      return 1
    fi
    branch_type=$(printf "%s\n" "${BRANCH_TYPES[@]}" | fzf --prompt="üß≠ Type de branche ? > " --height=10%)
    [[ -z "$branch_type" ]] && { echo -e "${YELLOW}‚ö†Ô∏è  Aucun type s√©lectionn√©.${RESET}"; return 1; }
    echo -ne "üìù Nom de la branche : "
    read name
    [[ -z "$name" ]] && { echo -e "${YELLOW}‚ö†Ô∏è  Nom requis.${RESET}"; return 1; }
  fi

  create_branch "$branch_type" "$name"
}

# Fonction finish universelle
finish() {
  local type=""
  local name=""
  local branch=""
  local current=""
  local open_pr=false

  # R√©cup√©ration du HEAD
  current=$(git rev-parse --abbrev-ref HEAD)

  # V√©rification pr√©sence de --pr
  for arg in "$@"; do
    if [[ "$arg" == "--pr" ]]; then
      open_pr=true
      set -- "${@/--pr/}" # suppression de l'argument de la liste
      break
    fi
  done

  # D√©duction des arguments restants
  if [[ $# -eq 0 ]]; then
    # D√©duire depuis la branche courante
    if [[ "$current" == */* ]]; then
      type="${current%%/*}"
      name="${current##*/}"
    else
      echo -e "${YELLOW}‚ö†Ô∏è Impossible de d√©terminer type/nom depuis la branche actuelle ($current).${RESET}"
      return 1
    fi
  elif [[ $# -eq 1 ]]; then
    if [[ "$1" == */* ]]; then
      type="${1%%/*}"
      name="${1##*/}"
    else
      type="$1"
      name="${current##*/}"
    fi
  elif [[ $# -eq 2 ]]; then
    type="$1"
    name="$2"
  else
    echo -e "${YELLOW}‚ö†Ô∏è Trop d'arguments. Usage : finish [type[/name]] | type name [--pr]${RESET}"
    return 1
  fi

  # Validation du type
  if [[ ! "$type" =~ ^(feature|fix|hotfix|chore)$ ]]; then
    echo -e "${YELLOW}‚ö†Ô∏è Type non support√© : ${type}.${RESET}"
    return 1
  fi

  branch="${type}/${name}"
  label="${type}(${name})"

  if [[ "$open_pr" = true ]]; then
    publish "$branch" || {
      echo -e "${RED}‚ùå Impossible de publier ${branch}, PR annul√©e.${RESET}"
      return 1
    }
    open_pr "$branch"
    return 0
  fi

  # Merge et suppression
  echo -e "${GREEN}üîÄ Fusion de la branche ${branch} dans main...${RESET}"
  git checkout main && git pull || return 1
  git merge --no-ff "$branch" -m "$label: merge ${type} into main" || return 1

  if git show-ref --verify --quiet "refs/heads/${branch}"; then
    git branch -d "$branch"
  fi

  if branch_exists_remote "$branch"; then
    git push origin --delete "$branch" 2>/dev/null || true
  fi
  echo -e "${GREEN}‚úÖ Branche ${branch} fusionn√©e et supprim√©e.${RESET}"
}


function sync_branch() {
  git fetch origin
  git rebase origin/main
  echo -e "${GREEN}üîÑ Branche synchronis√©e avec main.${RESET}"
}

publish() {
  local branch="${1:-$(git symbolic-ref --short HEAD)}"

  if ! git rev-parse --verify "$branch" >/dev/null 2>&1; then
    echo "‚ùå La branche locale '$branch' n'existe pas."
    return 1
  fi

  if branch_exists_remote "$branch"; then
    echo "‚úÖ La branche '$branch' est d√©j√† publi√©e sur origin."
  else
    echo "üì§ Publication de la branche '$branch' vers origin..."
    git push -u origin "$branch"
  fi
}


function open_pr() {
  local branch=$(git rev-parse --abbrev-ref HEAD)

  branch_type=$(echo "$branch" | cut -d'/' -f1)
  branch_name=${branch#"$branch_type"/}

  if [[ -z "${BRANCH_ICONS[$branch_type]}" ]]; then
    echo -e "${YELLOW}‚ö†Ô∏è  Type de branche non support√© : ${branch_type}${RESET}"
    exit 1
  fi

  local prefix="${BRANCH_ICONS[$branch_type]}"
  local title="${prefix}(${branch_name})"
  local body="${2:-Pull request automatique depuis \`$branch\` vers \`main\`}"

  publish "$branch" || return 1

  # Cr√©ation de la PR via GitHub CLI
  gh pr create --base main --head "$branch" --title "$title" --body "$body"

  # R√©cup√©ration du lien vers la PR
  local url=$(gh pr view "$branch" --json url -q ".url")
  echo -e "${GREEN}‚úÖ PR cr√©√©e depuis $branch vers main${RESET}"
  echo -e "üîó Lien : ${BOLD}${url}${RESET}"
}

branch_exists_remote() {
  local branch="$1"
  git ls-remote --heads origin "$branch" | grep -q "$branch"
}

# Dispatcher
case "$1" in
  start)
    shift
    start "$1"
    ;;
  finish)
    shift
    finish "$@"
    ;;
  start_feature)
    shift
    start_feature "$1"
    ;;
  pr)
    shift
    open_pr "$@"
    ;;
   publish)
    shift
    publish "$@"
    ;;
  help | *)
    print_help
    ;;
esac
